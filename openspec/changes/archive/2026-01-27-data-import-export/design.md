## Context

現在のタスクデータは Zustand の persist ミドルウェアにより localStorage（キー: `task-tree-storage`）に JSON 形式で保存されている。デバイス間の移行やバックアップ手段がないため、ファイルを介したインポート・エクスポート機能を追加する。

## Goals / Non-Goals

**Goals:**
- タスクデータを JSON ファイルとしてダウンロードできる
- JSON ファイルからタスクデータを読み込んで復元できる
- インポート時に既存データとの関係（置換）を明確にする

**Non-Goals:**
- CSV や他のフォーマットへの対応
- クラウド同期やリアルタイム共有
- インポート時の既存データとのマージ（既存データは置換される）
- データのバージョン管理やマイグレーション

## Decisions

### 1. エクスポート形式は Zustand ストアの内部形式をそのまま使う

**選択**: localStorage に保存されている `task-tree-storage` の `state.tasks` 配列をそのまま JSON ファイルとして出力する。

**理由**: Zustand persist が使っている形式と同一にすることで、変換ロジックが不要になり、インポート時もそのままストアに流し込める。

**代替案**: 独自のエクスポートスキーマを定義する → 変換コードが増え、メンテナンスコストが上がるため不採用。

### 2. ファイルダウンロードはブラウザの Blob + URL.createObjectURL を使う

**選択**: `Blob` を作成し、`<a>` 要素の `download` 属性でダウンロードする。

**理由**: 外部ライブラリ不要で、主要ブラウザすべてで動作する。

### 3. ファイル読み込みは `<input type="file">` + FileReader を使う

**選択**: hidden な `<input type="file" accept=".json">` を使い、ユーザーがファイルを選択したら `FileReader` で読み込む。

**理由**: 標準 API のみで実現でき、ドラッグ&ドロップよりもシンプル。

### 4. インポートは既存データを完全に置換する

**選択**: インポート時に既存タスクをすべて削除し、インポートデータで置き換える。

**理由**: マージロジックは ID の衝突やツリー構造の整合性など複雑な問題を伴う。まずはシンプルな置換から始める。

### 5. インポート前に確認ダイアログを表示する

**選択**: `window.confirm` でインポート前に確認する。

**理由**: 既存データが失われる操作のため確認が必要。モーダルコンポーネントを新規作成するほどの複雑さはない。

### 6. UI の配置はヘッダーにメニューボタンを追加する

**選択**: App.tsx のヘッダーにメニューボタン（アイコン）を追加し、エクスポート・インポートのアクションを配置する。

**理由**: タブとは独立した機能であり、ヘッダーのグローバル操作として配置するのが適切。

## Risks / Trade-offs

- **不正な JSON のインポート** → FileReader 後に JSON.parse を try-catch し、失敗時はエラーメッセージを表示する
- **データ構造が合わないファイルのインポート** → Task 型の必須フィールド（id, title, status, createdAt）の存在を検証し、不正な場合はエラーとする
- **大量データのインポート** → 現時点では考慮しない。localStorage の上限（約 5MB）がそのまま制約となる
