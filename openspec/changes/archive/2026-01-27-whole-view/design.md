## Context

現在、タスクのデータモデル（`Task` 型）と状態管理（Zustand ストア）は実装済み。`parentId` フィールドで親子関係を表現するフラットな配列構造でタスクを管理している。

UIは未実装で、App.tsx は Vite のデフォルトテンプレートのまま。

## Goals / Non-Goals

**Goals:**
- タスクの階層構造を視覚的に表示するツリービューを実装する
- 個別タスクの折り畳み/展開機能を提供する
- 全体の一括折り畳み/展開ボタンを提供する

**Non-Goals:**
- タスクの編集・削除機能（Phase 4, 5 で対応）
- ドラッグ&ドロップによる並び替え
- タスク詳細のドロワー表示（Phase 4 で対応）

## Decisions

### 1. コンポーネント構成

**決定**: 以下の3つのコンポーネントに分割する
- `TaskTreeView`: 全体のコンテナ（一括折り畳みボタン含む）
- `TaskTreeNode`: 個別タスクの表示（再帰的に子を表示）
- `TaskTreeItem`: タスク1行の表示（折り畳みトグル、タイトル、ステータス）

**理由**: 責務を明確に分離し、再帰構造を扱いやすくするため。TaskTreeNode が自身の子タスクを再帰的にレンダリングする。

### 2. 折り畳み状態の管理

**決定**: 折り畳み状態はローカルの React state（useState）で管理し、`Set<string>` で折り畳まれているタスクIDを保持する

**代替案**:
- Zustand ストアに追加 → UI状態を永続化する必要がないため過剰
- 各 TaskTreeNode で個別管理 → 一括操作が困難

**理由**: 一括折り畳み/展開操作を簡単に実装でき、ページリロード時にリセットされても問題ない

### 3. ツリー構造の構築

**決定**: `useMemo` でフラットな配列から親子関係のマップを構築する

```typescript
// parentId -> children[] のマップを作成
const childrenMap = useMemo(() => {
  const map = new Map<string | undefined, Task[]>();
  tasks.forEach(task => {
    const children = map.get(task.parentId) ?? [];
    children.push(task);
    map.set(task.parentId, children);
  });
  return map;
}, [tasks]);
```

**理由**: 毎回の再帰でフィルタリングするよりも効率的

### 4. スタイリング

**決定**: Tailwind CSS のユーティリティクラスでスタイリング。インデントは `ml-4` (1rem) を階層ごとに適用

**理由**: Shadcn/ui のデザインシステムと一貫性を保ちつつ、シンプルに実装できる

## Risks / Trade-offs

### [リスク] 大量のタスクでのパフォーマンス
深い階層や数百件のタスクで再帰レンダリングが重くなる可能性がある
→ **緩和策**: 折り畳み時は子コンポーネントをレンダリングしない。将来的に仮想化が必要になれば対応

### [トレードオフ] 折り畳み状態の非永続化
ページリロードで折り畳み状態がリセットされる
→ **許容**: 当面は問題なし。必要に応じて localStorage に保存を追加可能
