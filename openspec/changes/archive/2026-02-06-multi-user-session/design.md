## Context

現在のシステムは1ユーザー1セッションの構造で、以下の制約がある：
- セッションCookie（`session`）は単一のセッションIDのみを保持
- `auth-store` は1人のユーザー名のみを管理
- ログイン時に既存セッションは上書きされる

複数アカウントを持つユーザーが切り替えるたびにログアウト→ログインが必要で、ユーザー体験が悪い。

## Goals / Non-Goals

**Goals:**
- 複数ユーザーのセッションをブラウザ側で保持できるようにする
- 1クリックでユーザーを切り替え可能にする
- 既存の認証フローを壊さない

**Non-Goals:**
- 同時に複数ユーザーとしてAPIを呼び出すことは対象外（アクティブユーザーは常に1人）
- ユーザー数の上限設定は対象外
- セッションの自動同期（他タブとの同期）は対象外

## Decisions

### 1. セッション管理方式：フロントエンド管理 + 単一Cookie

**決定**: 複数セッションIDはフロントエンドの localStorage で管理し、バックエンドへのリクエスト時はアクティブユーザーのセッションIDのみを Cookie で送信する。

**代替案**:
- 複数セッションIDをCookieに保持: Cookie サイズ制限やパース複雑化の問題
- バックエンド側で複数セッション管理: 既存のセッションモデル変更が大規模

**理由**: バックエンド変更を最小限に抑えつつ、柔軟な複数セッション管理が可能。

### 2. セッション情報の保存形式

**決定**: localStorage に以下の形式で保存する
```typescript
interface StoredSession {
  sessionId: string;
  username: string;
}
// localStorage key: "sessions"
// value: StoredSession[] (JSON)
// localStorage key: "activeSessionId"
// value: string (現在アクティブなセッションID)
```

**理由**: シンプルで拡張性がある。ユーザー名をキャッシュすることで切り替え時のUI表示が即座にできる。

### 3. Cookie の動的設定

**決定**: ユーザー切り替え時に JavaScript から `document.cookie` でセッションCookieを書き換える。

**代替案**:
- 切り替え専用のバックエンドエンドポイント: 追加のAPIコールが発生

**理由**: フロントエンドのみで完結し、バックエンド変更が不要。ただし `HttpOnly` Cookie は JavaScript から書き換えられないため、新規ログイン時のみバックエンドが Cookie を設定し、切り替え時はフロントエンドが非HttpOnly の Cookie として再設定する。

### 4. ログイン時の動作

**決定**: 新規ログイン成功時、バックエンドは通常通り Cookie を設定。フロントエンドはレスポンス後に localStorage にセッション情報を追加。同じユーザーが既にログイン済みの場合は、古いセッションを置き換える。

### 5. ログアウト時の動作

**決定**:
- 単一ユーザーのログアウト: 当該セッションをlocalStorageから削除し、バックエンドの`POST /logout`を呼ぶ
- 他にセッションがあれば最初のセッションに自動切り替え
- セッションがなくなれば未ログイン状態に遷移

## Risks / Trade-offs

**[リスク] localStorage にセッションIDを保存するセキュリティ**
→ 緩和策: XSS対策が前提。localStorage は同一オリジンポリシーで保護される。機密性の高いアプリには不向きだが、タスク管理アプリとしては許容範囲。

**[リスク] Cookie の HttpOnly 属性が失われる**
→ 緩和策: 切り替え時のみ非HttpOnly。セッションIDは推測困難な64文字のランダム文字列のため、XSSがなければ漏洩リスクは低い。

**[トレードオフ] フロントエンドとバックエンドのセッション状態の不整合**
→ 許容: バックエンドでセッションが期限切れになった場合、次回API呼び出しで401が返り、フロントエンドがそのセッションを削除する。
