## Context

現在フロントエンドのタスクデータは Zustand の persist middleware を通じて localStorage のみに保存されている。バックエンドには認証付きのタスク CRUD API（`GET/POST/PATCH/DELETE /tasks`, `PATCH /tasks/{id}/reorder`）が実装済みだが、フロントエンドからは呼び出されていない。

ログインユーザーのタスクデータをバックエンドに同期させる仕組みを導入し、デバイス間でのデータ共有・データ保全を実現する。

## Goals / Non-Goals

**Goals:**

- ログインユーザーのタスク操作時に、バックエンド API へデータを送信する
- ログイン時に DB と localStorage 間で初期同期を行う
- リロード時にバックエンドのデータで localStorage を更新する
- 未ログインユーザーは従来通り localStorage のみで動作する

**Non-Goals:**

- 同期の競合解決（楽観的ロック、バージョニング等）は対象外
- リアルタイム同期（WebSocket 等）は対象外
- オフライン時のキューイングやリトライ機構は対象外
- バックエンド API の変更は対象外（既存 API をそのまま利用）

## Decisions

### 1. 同期の方向性：localStorage を状態ソースとし、バックエンドはバックアップ先とする

localStorage を引き続き Zustand ストアの単一の状態ソース（single source of truth）として維持する。タスク操作時はまず localStorage を更新し、その後バックエンドに非同期で送信する（fire-and-forget）。

**理由:** 既存の taskStore のアーキテクチャを最小限の変更で維持できる。バックエンドの応答を待たないため、UI の応答性が損なわれない。

**代替案:** バックエンドを状態ソースにする → taskStore の大幅な書き換えが必要になり、オフライン時に動作しなくなる。

### 2. 同期ロジックを専用モジュール `taskSyncService` として分離する

taskStore のアクション内から直接 fetch を呼ぶのではなく、`taskSyncService` というモジュールを作成し、バックエンド通信のロジックを集約する。taskStore の各アクションは操作後に taskSyncService の関数を呼び出す。

**理由:** taskStore のロジックをシンプルに保ちつつ、API 通信の関心事を分離できる。テストやモックが容易になる。

**代替案:** taskStore 内に直接 fetch を書く → ストアのロジックが肥大化し、関心の分離が損なわれる。

### 3. ログイン時の初期同期フロー

1. `GET /tasks` でバックエンドのタスクを取得
2. レスポンスが空配列 → localStorage のタスクを `POST /tasks` で1件ずつ DB に保存
3. レスポンスにタスクがある → DB のデータで localStorage（taskStore）を上書き

**理由:** 新規ユーザーがログイン前に作成したタスクを失わない。既存ユーザーはログインしたデバイスのデータに惑わされず、DB のデータが復元される。

### 4. リロード時の同期

ページリロード時（`checkAuth` でログイン済みと確認できた場合）に `GET /tasks` を呼び出し、DB のデータで localStorage を上書きする。

通常のタスク操作（作成・更新・削除・並べ替え）では、バックエンドにデータを送信するのみで、レスポンスによる localStorage の上書きは行わない。

**理由:** ユーザーの要件通り。操作のたびにバックエンドのレスポンスで状態を書き換えると、楽観的更新のメリットが失われる。

### 5. バックエンドへの一括保存 API は追加しない

初期同期でローカルデータを DB に保存する際、既存の `POST /tasks` を1件ずつ呼び出す。バルクインサート API は追加しない。

**理由:** バックエンド変更を最小限にするという方針に合致する。タスク数が通常数十件程度であり、パフォーマンス問題は起きにくい。

**代替案:** `POST /tasks/bulk` のようなエンドポイントを追加 → バックエンド変更が発生し、スコープが拡大する。

### 6. 認証状態の判定は authStore の `username` を参照する

taskStore の各アクションがバックエンド送信すべきかの判定に、`useAuthStore.getState().username` を参照する。`username` が `null` でなければログイン済みと判断する。

**理由:** authStore が既に認証状態を一元管理している。追加の状態管理が不要。

### 7. タスクの ID マッピング

フロントエンドで `crypto.randomUUID()` で生成した ID を、バックエンドの `POST /tasks` でもそのまま使う（バックエンドが DB 側で新しい UUID を生成する）。初期同期時にローカルタスクを DB に保存すると、DB 側で新しい ID が割り振られるため、保存後に `GET /tasks` で取得したデータで localStorage を上書きし、ID を含むすべてのフィールドを DB のものに揃える。

**理由:** フロントエンドの ID をバックエンドに渡す仕組みは既存 API にない。初期同期後に GET で取り直すことで、parentId の参照整合性も含めて一貫性を保てる。ただし、parentId の参照を維持するため、保存時は親タスクから先に保存し、旧 ID → 新 ID のマッピングを管理する必要がある。

## Risks / Trade-offs

- **API 通信失敗時にデータ不整合が発生する** → 現段階では許容する。同期制御は今後の課題とする。ユーザーがリロードすれば DB のデータで復元される。
- **初期同期中のタスク操作で不整合が発生する可能性** → 初期同期中は通常数秒以内に完了するため、実用上問題になりにくい。
- **初期同期で大量のタスクを1件ずつ POST する場合のパフォーマンス** → 一般的なユーザーのタスク数（数十件）では問題にならない。将来的にバルク API の追加で対応可能。
- **localStorage と DB のデータ形式の差異**（フロントエンド: camelCase、バックエンド: snake_case、日付形式の違い）→ taskSyncService 内で変換処理を行う。
