## Context

現在、タスクの折り畳み状態（`collapsedIds`）は zustand の persist 機能により localStorage にのみ保存されている。タスクデータ自体は既にバックエンドの PostgreSQL データベースに保存されており、ログインユーザーは複数デバイス間でタスクを同期できる。しかし、折り畳み状態は同期されないため、異なるデバイスからログインすると全タスクが展開状態で表示される。

ユーザー要件として「既存のタスクテーブルにカラムを追加する形で実装すること」が指定されている。

## Goals / Non-Goals

**Goals:**

- tasks テーブルに `is_collapsed` カラムを追加し、各タスクの折り畳み状態をバックエンドに保存する
- ログインユーザーの折り畳み状態を複数デバイス間で同期する
- 既存のタスク同期フローに折り畳み状態の同期を統合する
- 未ログインユーザーは引き続き localStorage で折り畳み状態を管理する（既存動作を維持）

**Non-Goals:**

- 別テーブル（例: user_preferences）での折り畳み状態管理は行わない
- 折り畳み状態のみの同期 API は作成しない（既存のタスク更新 API を拡張）
- リアルタイム同期（WebSocket）は行わない

## Decisions

### Decision 1: タスクテーブルへのカラム追加

**選択**: `tasks` テーブルに `is_collapsed BOOLEAN NOT NULL DEFAULT false` カラムを追加

**理由**:
- ユーザー要件で「既存のタスクテーブルにカラムを追加」と指定されている
- 折り畳み状態はタスクごとの属性であり、タスクテーブルに持たせるのが自然
- タスク取得時に追加クエリなしで折り畳み状態も取得できる

**代替案**:
- `user_collapse_preferences` テーブルを作成 → タスクとの JOIN が必要、実装複雑化
- localStorage のみ使用を継続 → デバイス間同期できない

### Decision 2: フロントエンドのデータ構造変更

**選択**: Task 型に `isCollapsed: boolean` フィールドを追加し、`collapsedIds` 配列を廃止

**理由**:
- バックエンドのデータ構造と一致させることで変換ロジックがシンプルになる
- 各タスクの折り畳み状態がタスクオブジェクト内で完結する

**代替案**:
- `collapsedIds` を維持し、同期時に変換 → 2つの状態管理が必要で複雑

### Decision 3: 同期タイミング

**選択**: 折り畳み操作時に即座に `PATCH /tasks/{id}` で `is_collapsed` を送信

**理由**:
- 既存のタスク更新フローと同じパターンで統一される
- 個別タスクの更新なので、データ量が小さく負荷が低い

**代替案**:
- デバウンスして一括送信 → 即時反映されず UX 低下、実装複雑化
- ページ離脱時に一括送信 → 離脱前にクラッシュするとデータ喪失

### Decision 4: 未ログインユーザーの折り畳み状態

**選択**: 未ログイン時は Task オブジェクトの `isCollapsed` フィールドを localStorage で永続化

**理由**:
- zustand persist により既に Task 配列全体が localStorage に保存されている
- 別途 `collapsedIds` を管理する必要がなくなる

## Risks / Trade-offs

**[Risk] マイグレーションで既存データの折り畳み状態が全てリセットされる**
→ Mitigation: `DEFAULT false` で全タスク展開状態として開始。ユーザー影響は軽微（再度折り畳めば良い）

**[Risk] 折り畳み操作ごとに API リクエストが発生し、サーバー負荷が増加する**
→ Mitigation: 既存の更新 API を使用するため追加エンドポイントは不要。リクエスト頻度はタスク編集と同程度で許容範囲

**[Trade-off] Task 型への isCollapsed 追加によりエクスポート/インポートで折り畳み状態が含まれる**
→ 仕様変更として許容。他デバイスへのデータ移行時にも折り畳み状態が引き継がれるメリットがある
