## Context

タスクツリーの折り畳み状態は現在 `TaskTreeView.tsx` の `useState<Set<string>>` でコンポーネントローカルに管理されている。ページリロードで状態がリセットされるため、タスク数が多いユーザーは毎回折り畳み直す必要がある。

既存の Zustand ストア (`taskStore.ts`) は `persist` ミドルウェアを使い、`task-tree-storage` キーで localStorage にタスクデータを永続化している。この仕組みを活用して折り畳み状態も永続化する。

## Goals / Non-Goals

**Goals:**

- 折り畳み状態を localStorage に永続化し、リロード後も復元する
- 既存の Zustand persist ミドルウェアを活用し、最小限の変更で実現する
- タスク削除時に不要な折り畳み状態をクリーンアップする

**Non-Goals:**

- エクスポート/インポートへの折り畳み状態の含有（UI状態でありタスクデータではないため）
- 複数デバイス間での折り畳み状態の同期
- 折り畳み状態の Undo/Redo 対応

## Decisions

### 1. 折り畳み状態の管理場所：既存の taskStore に追加

**選択:** `taskStore.ts` の既存ストアに `collapsedIds` を追加する

**代替案:**
- 折り畳み専用の別ストアを作成する → 状態が小さく単純なため、別ストアにするオーバーヘッドに見合わない
- カスタム hook + localStorage を直接使う → Zustand の persist が既にあるのに二重管理になる

**理由:** 既存の persist ミドルウェアがそのまま使えるため、追加の永続化ロジックが不要。タスク削除時のクリーンアップも同一ストア内で完結する。

### 2. データ構造：`string[]` で保存

**選択:** `collapsedIds` を `string[]` として Zustand ストアに保存する。コンポーネント側では `Set<string>` に変換して使用する。

**代替案:**
- `Set<string>` をそのまま保存する → JSON シリアライズで `Set` は空オブジェクトになるため不可
- `Record<string, boolean>` で保存する → 配列の方がシンプルで、保存データも小さい

**理由:** Zustand persist は JSON.stringify/parse でシリアライズするため、`Set` は使えない。配列が最もシンプルかつ JSON 互換性が高い。

### 3. 折り畳み操作のアクション設計

**選択:** 以下の3アクションをストアに追加する

- `toggleCollapse(id: string)`: 単一タスクの折り畳みトグル
- `collapseAll(ids: string[])`: 全親タスクを折り畳む
- `expandAll()`: 全タスクを展開する

**理由:** 現在の `TaskTreeView.tsx` にある3つの操作（トグル・全折り畳み・全展開）にそれぞれ対応する。

### 4. タスク削除時のクリーンアップ

**選択:** `deleteTask` アクション内で、削除対象タスクの ID を `collapsedIds` からも除去する。

**代替案:**
- 定期的なガベージコレクション → 複雑さに見合わない
- 復元時にフィルタリング → 不要なデータが蓄積される

**理由:** 削除と同じトランザクション内でクリーンアップすれば、不要データが蓄積されない。既に `deleteTask` は子タスクも再帰的に削除しているため、その ID リストを使って一括除去できる。

## Risks / Trade-offs

- **localStorage 容量**: 折り畳み状態は文字列配列なのでデータ量は小さい（UUID 36文字 × タスク数）。現実的な使用量では問題にならない → 対応不要
- **既存データとの互換性**: 新しいフィールドが追加されるが、Zustand persist はデフォルトで既存データとマージするため、既存ユーザーのデータは壊れない → リスク低
- **パフォーマンス**: 折り畳みトグルごとに localStorage 書き込みが発生するが、Zustand persist はデフォルトで同期的に書き込む。折り畳み操作頻度を考えると問題にならない → 対応不要
