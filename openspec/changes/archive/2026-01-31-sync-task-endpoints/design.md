## Context

フロントエンドは Zustand + localStorage でタスクデータを管理しているが、バックエンドには既に `tasks` テーブルと認証機構（セッションベース）が存在する。フロントエンドのデータをサーバーサイドで永続化するために、バックエンドに REST API エンドポイントを追加する。

現在のバックエンドは Go の `net/http` 標準ライブラリで構築されており、`pgxpool` を使って PostgreSQL に接続している。認証は `authMiddleware` がセッション Cookie を検証する方式。

## Goals / Non-Goals

**Goals:**

- 認証済みユーザーのタスクに対する CRUD 操作の API エンドポイントを提供する
- タスクの並び替え（`sortOrder` の変更）をサポートする
- 既存のデータベーススキーマ・認証機構をそのまま活用する
- フロントエンドの `Task` 型と互換性のある JSON レスポンスを返す

**Non-Goals:**

- フロントエンドの状態管理を API 連携に切り替える（別の change で対応）
- ページネーションや検索機能の実装
- リアルタイム同期（WebSocket など）
- タスクの一括操作（バルクインサート、バルクデリートなど）

## Decisions

### 1. ハンドラーのファイル構成

**決定**: タスク関連のハンドラーを `task.go` として新規ファイルに実装する。

**理由**: 既存の `auth.go`、`health.go` と同様に機能単位でファイルを分割するパターンに従う。タスク操作は 5 エンドポイント分のコード量があるため、独立ファイルが適切。

### 2. ユーザー ID の取得方法

**決定**: `authMiddleware` を拡張し、認証成功時にセッションから `user_id` を取得して `context.Context` に格納する。各ハンドラーは context からユーザー ID を取り出す。

**理由**: 現在の `authMiddleware` はセッションの有効性のみ検証しているが、タスク操作ではどのユーザーのタスクかを特定する必要がある。context への格納は Go の標準的なパターンであり、ハンドラー間でのユーザー情報共有に適している。

**代替案**: 各ハンドラーで個別にセッション → ユーザー ID を問い合わせる方法もあるが、DB クエリの重複が発生するため不採用。

### 3. レスポンスの JSON フィールド名

**決定**: Go 側では `snake_case`（DB カラム名と一致）でレスポンスを返す。

**理由**: Go の JSON タグで `snake_case` を指定するのが自然であり、DB カラム名との対応も明確になる。フロントエンド側での `camelCase` 変換は API クライアント層で対応する（本 change のスコープ外）。

### 4. 並び替えエンドポイントの設計

**決定**: `PATCH /tasks/{id}/reorder` で `sort_order` を受け取り、対象タスクの `sort_order` のみを更新する。

**理由**: フロントエンド側で並び替えロジック（兄弟タスク間の `sortOrder` 再計算）を持っているため、バックエンドは単一タスクの `sort_order` を更新するだけで十分。サーバーサイドで全兄弟の再計算を行うと、フロントエンドのロジックと二重管理になる。

### 5. エラーレスポンス形式

**決定**: エラー時は HTTP ステータスコードとプレーンテキストのエラーメッセージを返す（`http.Error` を使用）。

**理由**: 既存の `auth.go` と同じパターンに合わせる。構造化エラーレスポンス（JSON 形式）はフロントエンド統合時に必要に応じて導入する。

### 6. 一覧取得のレスポンス構造

**決定**: `GET /tasks` はログインユーザーの全タスクをフラットな配列で返す。ツリー構造への組み立てはフロントエンド側で行う。

**理由**: フロントエンドには既に `parentId` を使ったツリー構築ロジックがある。サーバーサイドでツリーを組み立てると、フロントエンドの既存ロジックと重複する。

## Risks / Trade-offs

- **認可チェックの漏れ**: 各ハンドラーで `user_id` によるフィルタリングを徹底する必要がある。タスク更新・削除時に対象タスクが当該ユーザーのものであることを必ず検証する → クエリの WHERE 句に `user_id` 条件を含めることで対応
- **parent_id の整合性**: 作成時に `parent_id` が指定された場合、そのタスクが同一ユーザーのものであることを検証する必要がある → INSERT 前に parent の存在と所有者を確認するクエリを実行
- **N+1 問題**: 一覧取得で全タスクを一括取得するため、タスク数が多い場合にレスポンスが大きくなる → 当面はタスク数が限られているため問題なし。将来的にはページネーションで対応
